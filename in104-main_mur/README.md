Ceci est le ReadMe détaillant le dossier in104-main_mur.

Pour compiler le code, il faut écrire la commande " gcc -Wall -Werror -Wfatal-errors dfs.c functions.c mazeEnv.c qlearningmur.c choix_action.c -lm ",- ou utiliser le makefile.

Tout d'abord, la raison pour laquelle ce fichier s'appelle ainsi est parce que nous avons recodé maze_step en maze_step_mur. En effet, nous avons rencontré des problèmes (core dumped notamment) qui après une longue examination se sont révélés issus d'une tentative d'accès a des cases hors limites du labyrinthe. De plus, notre algorithme passait à travers les murs (et atteignait ainsi l'arrivée en un record de 11 coups), ce qui limite évidemment l'intérêt de ce projet. Nous avons donc éliminé ces erreurs avec la fonction maze_step_mur, placée dans mazeEnv.c . C'est, dans le cas 2D et donc dans ce dossier, la seule modification majeure apportée à mazeEnv.c .

Le fichier choix_action.c contient les codes des algorithmes de choix Epsilon-greedy et Boltzmann-exploration. Les fonctions correspondantes sont respectivement nommées epsi_greed() et Bolt().

Le noyau du code est dans la fonction qlearningmur.c . Ce fichier un peu long contient en réalité à la fois l'algorithme de Q-learning et l'algorithme Sarsa, placés en if/else pour pouvoir choisir le type d'algorithme. La fonction qui initialise le tableau Q est également dans ce fichier.
La fonction principale de ce fichier est tableau(), qui réalise le calcul de Q, itération après itération. Cette fonction est donc divisée en deux morceaux par un premier if/else, pour différencier Sarsa du Q-learning. Chacune de ces options est également divisée en deux morceaux : une première boucle for qui laisse l'algorithme évoluer dans le labyrinthe pendant de nombreuses itérations et met constamment à jour le tableau Q, puis un dernier tour dans lequel l'algorithme suit toujours le maximum du tableau Q final et note le nombre de coups. Cette dernière itération passe par un choix en Espilon-greedy avec Epsilon = 0 pour toujours prendre le coup considéré comme optimal, et place des '.' dans les différentes cases jusqu'à l'arrivée. 

Le fichier dfs.c, comme au tout début du projet, contient le main. Il demande à l'utilisateur de rentrer les paramètres et le mode d'algorithme choisis par des scanf() successifs, affiche le labyrinthe vide une première fois, puis exécute la fonction tableau() de qlearningmur.c . Il affiche alors de nouveau le labyrinthe, cette fois-ci avec le trajet optimal de l'algorithme tracé par des '.' . Le nombre de coups final est également affiché.
